<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux内存生存之道]]></title>
    <url>%2F2018%2F07%2F23%2Flinux%E5%86%85%E5%AD%98%E7%94%9F%E5%AD%98%E4%B9%8B%E9%81%93%2F</url>
    <content type="text"><![CDATA[earlyoom1sudo apt install earlyoom 关闭 earlyoom1systemctl stop earlyoom memory_overcommit.cc从卡死中恢复：在运行 memory_overcommit.cc 之前，先修改 /etc/sysctl.d/99-sysctl.conf （也可能是同一目录下的其它名字），把 kernel.sysrq=0 （或其它值）改为 kernel.sysrq=1 ；然后重启系统，或执行 sudo sysctl kernel.sysrq=1 立即生效。 在卡死后，按下组合键 alt + sysrq + r然后按 alt + sysrq + f这是为了手工执行 oom killer。oom killer 可能要延迟几秒钟才执行，所以不要急不可耐的反复按 alt + sysrq + f ，以免杀掉很多无辜进程。sysrq 就是 print screen 键。 Cpp编译 memory_overcommit.cc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;cassert&gt;#include &lt;cerrno&gt;#include &lt;clocale&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;limits&gt;using std::exit;using std::numeric_limits;using std::printf;using std::size_t;using std::strlen;void read_answer(char* buffer, size_t buffer_size)&#123; assert(buffer_size &gt; 1); char const* ret = std::fgets(buffer, buffer_size, stdin); if(ret == 0) &#123; printf("\nSorry, there was an error while reading the answer. This program will now terminate.\n"); exit(EXIT_FAILURE); &#125; else if(strlen(buffer) == buffer_size - 1 &amp;&amp; buffer[buffer_size - 2] != '\n') &#123; printf("Sorry, you answer is too long (possibly out of range). This program will now terminate.\n"); exit(EXIT_FAILURE); &#125;&#125;size_t determine_size(char const* s)&#123; assert(strlen(s) &gt; 0); char* endptr = 0; errno = 0; unsigned long v = std::strtoul(s, &amp;endptr, 10); if(strlen(s) == 1 || endptr != s + strlen(s) - 1) &#123; printf("\nSorry, your answer does not appear to be valid. This program will now terminate.\n"); exit(EXIT_FAILURE); &#125; else if((v == numeric_limits&lt;unsigned long&gt;::max() &amp;&amp; errno == ERANGE) || v == 0 || numeric_limits&lt;unsigned long&gt;::max() / (1024 * 1024) &lt; v) &#123; printf("\nSorry, that value is out of range. This program will now terminate.\n"); exit(EXIT_FAILURE); &#125; v *= 1024 * 1024; assert(numeric_limits&lt;size_t&gt;::is_specialized); if(v &gt; numeric_limits&lt;size_t&gt;::max() ) &#123; printf("\nSorry, that value is out of range. This program will now terminate.\n"); exit(EXIT_FAILURE); &#125; return v;&#125;bool inquire_repeat(size_t&amp; v)&#123; printf("\nShould a new allocation be made? You can enter:\n" "==&gt; \"No\" to quit,\n" "==&gt; Any Number of MiB to change the chunk size and continue, or\n" "==&gt; Hit return to continue with last chunk size.\n\nYour answer: "); char answer[20]; read_answer(answer, sizeof(answer) ); if(std::strcmp(answer, "\n") == 0) &#123; return true; &#125; else if(std::strcmp(answer, "No\n") == 0) &#123; return false; &#125; v = determine_size(answer); return true;&#125;int main() &#123; #ifdef _POSIX_C_SOURCE std::setlocale(LC_ALL, ""); // Prepare thousands grouping in output. #endif printf("\n\nThis program allows to repeatedly allocate chunks of memory of user-specified size. " "\nAfter each allocation the user can choose to repeat or to quit the program.\n\nFirst, please enter now " "the amount of memory in MiB (1024 * 1024 bytes) \nto allocate in each round: "); char answer[20]; read_answer(answer, sizeof(answer) ); size_t alloc_size = determine_size(answer); size_t total = 0; do &#123; printf("\n &gt;&gt;&gt; Starting to allocate chunk...\n"); std::fflush(stdout); void* p = std::malloc(alloc_size); if(!p) &#123; printf("\n &gt; The last memory allocation failed." "\n &gt; This means the system reported the out-of-memory condition orderly." "\nThis program will now terminate.\n"); exit(0); &#125; std::memset(p, 0, alloc_size); printf(" &gt;&gt;&gt; A chunk was just allocated! &lt;&lt;&lt;\n"); if(numeric_limits&lt;size_t&gt;::max() - total &gt;= alloc_size) &#123; total += alloc_size; #ifdef _POSIX_C_SOURCE char const* fmt_string = " The total number of bytes allocated is now %'zu.\n"; #else char const* fmt_string = " The total number of bytes allocated is now %zu.\n"; #endif printf(fmt_string, total); &#125; else &#123; #ifdef _POSIX_C_SOURCE char const* fmt_string = " More than %'zu bytes have been allocated in total by now.\n"; #else char const* fmt_string = " More than %zu bytes have been allocated in total by now.\n"; #endif printf(fmt_string, total); total = numeric_limits&lt;size_t&gt;::max(); &#125; &#125; while(inquire_repeat(alloc_size) ); printf("\nQuit was requested. This program will now terminate.\n");&#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坚果云ssl链接失败]]></title>
    <url>%2F2018%2F07%2F21%2F%E5%9D%9A%E6%9E%9C%E4%BA%91ssl%E9%93%BE%E6%8E%A5%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[备份并移除老的cacerts1sudo mv /etc/ssl/certs/java/cacerts&#123;,.backup&#125; 生成新的cacerts1sudo keytool -importkeystore -destkeystore /etc/ssl/certs/java/cacerts -deststoretype jks -deststorepass changeit -srckeystore /etc/ssl/certs/java/cacerts.backup -srcstoretype pkcs12 -srcstorepass changeit 重启坚果云]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql2]]></title>
    <url>%2F2018%2F07%2F21%2Fmysql2%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425-- 建表CREATE TABLE student14zs(Sno CHAR(4)PRIMARY KEY,Sname CHAR(40)UNIQUE,Ssex CHAR(2),Sage SMALLINT,Sdept CHAR(20));CREATE TABLE course14zs(Cno CHAR(4)PRIMARY KEY,Cname CHAR(40)NOT NULL,Cpno CHAR(4),Ccredit SMALLINT,FOREIGN key(Cpno)REFERENCES course14zs(Cno));CREATE TABLE SC14zs(Sno CHAR(9),Cno CHAR(4),Grade SMALLINT,PRIMARY KEY(Sno,Cno),FOREIGN key(Sno)REFERENCES student14zs(Sno),FOREIGN KEY(Cno)REFERENCES course14zs(Cno)); 12345678910-- 添加记录INSERT INTO student14zs(Sno,Sname,Ssex,Sage,Sdept) VALUES(3,'xom','x',21,620);INSERT INTO student14zs(Sno,Sname,Ssex,Sage,Sdept) VALUES(1,'aom','l',20,621);INSERT INTO student14zs(Sno,Sname,Ssex,Sage,Sdept) VALUES(2,'bom','x',22,622);INSERT INTO student14zs(Sno,Sname,Ssex,Sage,Sdept)VALUES(4,'1om','x',21,620),(5,'2om','x',21,620),(6,'3om','x',21,620);INSERT INTO course14zs()VALUES(1,'高数',1,100),(2,'线代',2,100),(3,'数据库',2,100); 123-- 修改列的数据类型ALTER TABLE student14zsMODIFY COLUMN Sage tinyint; 123-- 修改某一个值UPDATE sc14zs set Grade=89WHERE Sno=6 AND Cno=3; 123-- 删除表中的某一列alter table student14zsdrop column Sage; 12345678910111213-- 删除某一个值-- 唯一约束alter table student add unique key(Sname);-- 约束默认值为男alter table student14zs alter Ssex set default '男';-- grade&gt;0and grade&lt;100alter table sc14zs add check (Grade&gt;0 and Grade&lt;100);-- 添加一列出生日期alter table student14zs add column deta Sdate not null; `sql–查询 – 1. 查询某一列 *表示全部SELECT SnoFROM student14zs – 2. 查询年龄小于25岁的SELECT SnameFROM student14zs WHERE Sage&lt;25; – 出生日期1990年之前SELECT Sname,Sage,2018-SageFROM student14zs WHERE 2018-Sage&lt;1998; – 查询1990年以前出生的女生信息SELECT Sname,Sdeta,SsexFROM student14zs WHERE YEAR(Sdeta)&gt;1997 AND Ssex= ‘l’; – COUNT（统计） SUM AVG MAX MIN 函数 来求值SELECT Max(Grade) FROM sc14zs WHERE Cno=2; – 隐士链接SELECT student14zs.,sc14zs.FROM student14zs,sc14zs WHERE student14zs.Sno=sc14zs.Sno; – 3. 查询学生学号、姓名、课程号和成绩（包括未选修课程的学生的信息）。SELECT student14zs.Sno,Sname,Cno,GradeFROM student14zs LEFT OUTER JOIN 14zsON(student14zs.Sno=sc14zs.Sno) – 4. 查询学生学号、姓名、课程号和成绩（只包括选修了课程的学生的信息）。SELECT student14zs.Sno,Sname,Cno,GradeFROM student14zs , sc14zsWHERE(student14zs.Sno=sc14zs.Sno); – 5. 查询学生学号、姓名、课程名和成绩。SELECT student14zs.Sno,Sname,Grade,CnameFROM student14zs,sc14zs,course14zsWHERE student14zs.Sno=sc14zs.Sno AND sc14zs.Cno=course14zs.Cno – 查询所有与“数据库”有关的课程的信息。//选择从哪几个表里找SELECT *FROM student14zs,sc14zs,course14zsHAVING Cname =’数据库’ – 7. 按学分降序显示课程表中的信息。降序：select from 表名order by表中的字段descSELECT FROM 14zsORDER BY Ccredit DESC – 统计选课成绩表中每门课的平均成绩和选课总人数。SELECT Cno, AVG(Grade),COUNT(Sno)FROM sc14zsGROUP BY Cno; – GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组 – 9. 查询未选修课程的学生的学号和姓名SELECT Sno,SnameFROM student14zsWHERE NOT EXISTS( SELECT* FROM sc14zs WHERE Sno= student14zs.Sno); – 10. 查询02号课程的成绩比03号课程高的学生的学号SELECT DISTINCT SnoFROM student14zsWHERE EXISTS( SELECT Grade FROM sc14zs WHERE student14zs.Sno=sc14zs.Sno AND Cno=’3’)&lt;(SELECT Grade FROM sc14zs WHERE student14zs.Sno=sc14zs.Sno AND Cno=’2’ );]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[day12-EL]]></title>
    <url>%2F2018%2F07%2F20%2Fday12-EL%2F</url>
    <content type="text"><![CDATA[[TOC] EL表达式1. EL作用 获取数据 执行基本的关系与逻辑运算 获取web应用中的常用对象 调用Java方法 2. 例子12345&lt;% String data = "asdf"; request.setAttribute("data",data);%&gt;$&#123;data&#125; &lt;%-- pageContext.findAttribute("data") --%&gt; 12$&#123;p.address.city&#125;$&#123;list['1'].name&#125; 域 范围： page request session application 3. 运算表达式1. EL关系运算符 关系运算符 说明 范例 结果 == 或 eq 等于 ${5==5}或${5eq5} TRUE != 或 ne 不等于 ${5!=5}或${5ne5} FALSE &lt; 或 lt 小于 ${3&lt;5}或${3lt5} TRUE &gt; 或 gt 大于 ${3&gt;5}或{3gt5} FALSE &lt;= 或 le 小于等于 ${3&lt;=5}或${3le5} TRUE &gt;= 或 ge 大于等于 ${3&gt;=5}或${3ge5} FALSE 2. empty运算符：检查对象是否为null或空${empty(list)} -&gt; true 3. 二元表达式：${user!=null?user.name:&quot;&quot;} 4. 二元表达式数据回显：1234567&lt;% User user = new User(); user.setGender("male"); request.setAttribute("user",user);%&gt;&lt;input type="radio" name="gender" value="male" $&#123;user.gender=='male'?'checked':''&#125;&gt;男&lt;input type="radio" name="gender" value="female" $&#123;user.gender=='female'?'checked':''&#125;&gt;女 4. EL表达式不支持字符串连接JSP九大隐式对象JSP的隐式对象是指在JSP页面系统中已经默认内置的Java对象，这些对象不需要开发人员显式声明即可使用。 1. application: application对象有效的范围是从web应用程序服务器一开始执行，到web服务器结束服务为止。 对于一个网站中所有的JSP页面，application对象只有一个。它们操作的是同一个application对象。 application是一个全局变量，所有访问同一服务器的客户都可访问application对象。 12345678910111213&lt;% int count = 0; if(application.getAttribute("count") == null)&#123; count = 1; application.setAttribute("count", count); &#125;else&#123; //存进去的是int值，返回的也将是int值，而不是String类型 count = (Integer)(application.getAttribute("count")); count ++; application.setAttribute("count", count); &#125; out.print("你是第"+count+"位访客...");%&gt; 获取服务器系统相关信息application对象负责提供应用程序在服务器中运行时的一些全局信息，因此我们可以利用application来获取一些系统相关信息。123456&lt;% out.print("服务器信息: " + application.getServerInfo()+"&lt;br/&gt;"); out.print("Java Servlet API 主版本号: " + application.getMajorVersion()+"&lt;br/&gt;"); out.print("Java Servlet API 次版本号: "+application.getMinorVersion()+"&lt;br/&gt;"); out.print("本网页的真实路径："+application.getRealPath("index1.jsp")+"&lt;br/&gt;");%&gt; 将得到输出结果:服务器信息: Apache Tomcat/7.0.55Java Servlet API 主版本号: 3Java Servlet API 次版本号: 0本网页的真实路径： E:\Code\Java-Newer.metadata.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\jsp_ysdx\index1.jsp 2. config config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数及服务器的有关信息。 主要是对web.xml的数据进行读取。实际上是通过getServletContext()方法获得application对象，再根据application对象获得。可以直接在网页中获得web.xml中设置的数据。1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;Config&lt;/servlet-name&gt; &lt;!-- 此处要设置为将使用该数据的网页名 --&gt; &lt;jsp-file&gt;/index1.jsp&lt;/jsp-file&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;Chalmers&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Config&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/config&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 12out.print("username: " + config.getInitParameter("username")+ "&lt;br/&gt;"); out.print("password:" + config.getInitParameter("password")); 输出结果为:username: Chalmers 3. exception作用如名所示，用来处理页面异常的。 exception对象常用方法如下 getMessage()方法 toString()方法 printStackTrace()方法 getLocalizedMessage()方法 fillStackTrace()方法 用法:注意:exception对象只能在定义了&lt;%@ page isErrorPage=”true”%&gt;中使用，否则没有该对象testException.jsp123456&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ page errorPage="handleException.jsp"%&gt; &lt;% int a = 0; int b = 10 / a;%&gt; 12345678910111213141516171819202122232425262728293031&lt;%--handleException.jsp--%&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;%@ page isErrorPage="true"%&gt;&lt;% out.print(exception.getMessage() + "&lt;br/&gt;"); exception.printStackTrace();%&gt;``` ## 4. out1. out对象主要用于向浏览器端输出数据2. out实际上是带有缓冲特性的PrinterWriter，可以称之为JspWriter。缓冲区容量是可以设置的，甚至也可以关闭，只要通过page指令的buffer属性就可以达到此目的。3. JSP文件代码中的文件内容会自动生成out.print()或者out.println()输出。## 5. page1. page对象指代JSP页面本身、代表了正在运行的由JSP文件产生的类对象。2. page对象的常用方法如下。 1. getClass()方法 2. equals()方法 3. clone()方法实际上就是从Object中继承的方法## 6. request1. 请求有效：请求页面A，并向A中传递某些参数。2. 请求有效对象在处理结束时就会失效。3. request对象可以获取哪些信息 1. 建立HTML表单 ```XML &lt;form action=“action” method=“method” name=“name”&gt;。。。&lt;/form&gt; 用REQUEST对象处理JSP页面将数据存放在request对象里，并将该请求传递到下一个页面，下一个页面访问request对象，处理上一个JSP页面传递过来的数据。 通过超链接来传递 1&lt;a href="aaa.jsp?aa=aa&amp;bb=bb&amp;cc=cc"&gt;aaa&lt;/a&gt; 通过jsp动作标签param来进行传递 传递一组数据1234567//发送一组数据到receive.jsp&lt;form action="receive.jsp" method="post"&gt; 跑步&lt;input type="checkbox" name="habits" value="running" /&gt;&lt;br /&gt; 阅读&lt;input type="checkbox" name="habits" value="reading" /&gt;&lt;br /&gt; 游戏&lt;input type="checkbox" name="habits" value="game" /&gt;&lt;br /&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt; 接收参数要一致 1234String[] habits = request.getParameterValues("habits");for(String s : habits)&#123; out.print(s+"&lt;br/&gt;");&#125; 7. response response对象负责将服务器端的数据发送回浏览器的客户端。主要用于向客户端发送数据，如Cookie、HTTP文件头等信息。 利用response实现自动刷新 刷新当前界面12response.setHeader("refresh", "3");out.print(new Date().toString()); 结果:每隔3秒刷新一次界面，显示当前时间 跳转界面&lt;%out.print(“3秒后刷新…”);response.setHeader(“refresh”, “3;url=count.jsp”);%&gt; 添加Cookie 12345678910111213141516171819202122232425262728293031323334353637383940&lt;% Cookie cookie = new Cookie("username", "Chalmers"); //设置保存时间为60*60秒 cookie.setMaxAge(60 * 60); response.addCookie(cookie);%&gt;``` ```JAVA&lt;% Cookie[] cookies = request.getCookies(); for (Cookie c : cookies) &#123; if (c.getName().equals("username")) &#123; out.print(c.getValue()); return; &#125; &#125; out.print("没有...");%&gt;``` ## 8. pageContext1. pageContext对象能够存取其他隐含对象。2. 当隐含对象本身也支持属性时，pageContext对象也提供存取那些属性的方法。## 9. session1. session对象用于存储一个用户的会话状态，也就是说，session对象是对某个用户的会话过程中的信息存储。2. 当客户端访问服务器时，会在服务器中搜索对应的sessionID，如果没有找到，那么便会创建一个，如果找到了便直接使用。所以在session 的有效时间内，每个客户端只有一个sessionID。## 10 . pageContext，request、session、application传递参数的使用范围:1. 设置参数值```JAVA&lt;% pageContext.setAttribute("pageContext", "true"); request.setAttribute("request", "true"); session.setAttribute("session", "true"); application.setAttribute("application", "true");%&gt; 当前页面中，所有的对象都可以通过getAttribute获得值 在request的forward方法传递中，pageContext接收数据失败，所以pageContext只能在定义页面中使用。 request的include方法同上 如果使用response的sendRedirect方法，那么request也将接收失败。原因：客户端向服务端请求数据，服务端在向客户端发送数据完成后，该request便已经结束，客户端访问url时已经是一个新的request了，所以request的使用范围是一个request内。 在session的有效时间内，数据都是存在的，特别强调的是，关闭浏览器不会清除掉session。 而application只有在关闭服务端后才会被清除，可见上面的application介绍。 总结:范围大小: application &gt; session &gt; request &gt; pageContext 11. Cookie与Session的区别Cookie是存在浏览器中的Session是存在服务器中的Cookie的安全性要低于SessionCookie可能会被用户禁用Session的数据是存在服务器内存中，关掉浏览器，会清空Session临时性Cookie存在浏览器的缓存中，关掉浏览器，会清空永久性Cookie是存在临时文件中，到达有效期前，一直存在]]></content>
      <tags>
        <tag>Javaweb</tag>
        <tag>Mvc</tag>
        <tag>Day0</tag>
        <tag>El</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EMUI8.0官方解锁教程]]></title>
    <url>%2F2018%2F07%2F20%2FEMUI8-0%E5%AE%98%E6%96%B9%E8%A7%A3%E9%94%81%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[EMUI8.0官方解锁教程。######[2018.06.19] 此教程扒自华为官网，因为官方即将停止解锁码申请服务，所以页面可能删除，备份。 解锁步骤第一步：准备工作 在PC上正确安装手机驱动程序，驱动请在华为终端官网上下载。 下载Google提供的ADB工具包并在PC上安装，如安装到D:\adb_tools-2.0目录，确认目录中带有fastboot.exe文件。 第二步：解锁操作 手机进入fastboot模式：先将手机关机（注意需要首先在设置菜单中，关闭“快速启动”功能，或者关机后拔下电池，超过2秒后再重新插入），然后同时按下音量下键以及开机键（平板请同时按下音量上键及开机键），并保持10秒钟以上时间，就可以进入fastboot模式。 如果上述操作无法进入fastboot模式，请尝试使用如下步骤： 将手机关机（注意需要首先在设置菜单中，关闭“快速启动”功能，或者关机后拔下电池，超过2秒后再重新插入），然后插入USB线，紧接着同时按下音量下键和开机键，保持10秒钟以上时间，就可以进入fastboot模式。 连接手机和PC机：使用USB线连接手机和PC机，打开PC机的命令行窗口，进入ADB安装目录，确认手机与PC连接正常，确认方法为在命令行窗口输入fastboot devices，可以看到正常连接的信息，如：9e42530e fastboot。 执行解锁命令：在PC机命令行窗口中输入 fastboot oem unlock *** 星号为16位解锁密码，例如：fastboot oem unlock 1234567812345678。 等待手机解锁完成：输入解锁密码后，手机将自动重启，如果输入密码正确，手机将进入恢复出厂设置模式。恢复出厂设置完成后，手机自动重启，进入待机界面，完成整个解锁操作。如果用户输入密码信息不正确，手机将提示出错信息，并进入待机界面。 查询手机解锁是否成功：重复1、2步，然后在PC的命令行窗口中输入fastboot oem get-bootinfo，将显示当前手机bootloader的状态信息，例如“Bootloader Lock State: LOCKED”，表示bootloader仍处于锁定状态，请重新进行解锁操作或者确认密码是否正确后再进行；如果显示“Bootloader Lock State: UNLOCKED”，表示手机已经解锁，可以进行刷机操作。 注意：解锁成功后，如果希望将手机重新加锁请按以下步骤操作：首先，通过SD卡升级方式，将手机版本重新恢复为华为官方发布版本；然后，进入fastboot模式， 在PC的命令行下输入命令fastboot oem relock ** 星号为16位解锁密码。手机将自动重启，bootloader转换为“RELOCKED”状态。]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaweb-old]]></title>
    <url>%2F2018%2F07%2F20%2Fjavaweb-old%2F</url>
    <content type="text"><![CDATA[javaweb12345678910111213141516171819public void doGet(HttpServletRequest request,HttpServletResponse response)throws ServletException, IOException &#123; //通过servletcontext读取资源文件 InputStream in=this.getServletContext().getResourceAsStream("/WEB-INF/classes/db.properties"); /*************************/ // 绝对路径 String path =this.getServletContext().getRealPath("/WEB-INF/classes/db.properties"); FileInputStream in= new FileInputStream(path); /*************************/ Properties pros =new Properties(); //map pros.load(in); String url = pros.getProperty("url"); System.out.println(url); &#125; // db.properties // url=jdbc:myspl://localhost:3306/test // username=root // password=root 构造函数 Source -&gt; Generate Getters and Setters构造函数 Source -&gt; Generate Constructor using Fields空参构造函数 Source -&gt; Generate Constructors from Superclass encodeURL 10//分钟 session.invalidate(); jsphtml内容 -&gt; 模板元素脚本片段&lt;% …%&gt;单个代码可以不完整 多个不可以 输出123456&lt;%=time%&gt;&lt;%! public void run()&#123;&#125; static()&#123;&#125;%&gt; &lt;%– jsp注释 –%&gt; //不会打给浏览器 //会打给浏览器 jsp指令 1&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8" session="false" isThreadSafe="false" errorPage="/errors.jsp"%&gt; page指令import=”java.util.*“ date自动导包 res req sys java.lang.* javax.servlet.* javax.servlet.jsp.* javax.servlet.http.* 全局配置web.xml 错误处理页面123456789&lt;error-page&gt;&lt;exception-type&gt;java.lang.Arithmeticexception&lt;/exception-type&gt;&lt;location&gt;/error.jsp&lt;/location&gt;&lt;/erreo-page&gt;&lt;error-page&gt;&lt;error-code&gt;404&lt;/erreo-code&gt;&lt;location&gt;/404error.jsp&lt;/location&gt;&lt;/erreo-page&gt; isErrorPage=”true” //显示错误 编码指令 pagepageEncoding=”gb2312” contentType=”text/html” charset=”gb2312” include静态包含1234&lt;body&gt;&lt;%@include file="/public/head.jsp"@%&gt; //包含head页面所有信息&lt;%@include file="/public/foot.jsp"@%&gt;&lt;/body&gt; 动态包含123&lt;%request.getRequestDispatcher("/public/head.jsp").include(request,response);%&gt; 123&lt;%request.getWriter().write("aaaaaa&lt;br/&gt;");%&gt; 九大隐式对象 request response page application session config exception out pageContext JSP3大标签 page taglib include 七大动作 &lt;jsp:forward page=”index.jsp”&gt;&lt;/jsp:forward&gt;执行页面转向，将请求的处理转发到下一个页面。 jsp:param name=”username” value=”xxxx” &lt;%=x%&gt; 用于传递参数，必须与其他支持参数曲标签一起使用。 jsp:include: 用于动态引入一个 JSP 页面。 动态包含n个servlet jsp:p1ugin: 用于下载 JavaBean 或 Applet 到客户端执行。 jsp:useBean: 使用 JavaBean。 jsp:setProperty: 修改 JavaBean 实例的属性值。 jsp:getProperty: 获取 JavaBean 实例的属性值。 四个域对象css相对定位 没有相对定位就相对于边框绝对定位 12out.write("hahaha"); //有缓冲 默认8kb 最后到 responseresponse.getWriter().write("123123"); // 直接-&gt;response 123123]]></content>
      <tags>
        <tag>Javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux查看系统启动和运行时间]]></title>
    <url>%2F2018%2F07%2F20%2FLinux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[1echo 系统启动时间：;date -d &quot;$(awk -F. &apos;&#123;print $1&#125;&apos; /proc/uptime) second ago&quot; +&quot;%Y-%m-%d %H:%M:%S&quot; ; cat /proc/uptime| awk -F. &apos;&#123;run_days=$1 / 86400;run_hour=($1 % 86400)/3600;run_minute=($1 % 3600)/60;run_second=$1 % 60;printf(&quot;已运行：\n%d天%d时%d分%d秒\n&quot;,run_days,run_hour,run_minute,run_second)&#125;&apos;; cnblogs:努力哥]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC-day0910]]></title>
    <url>%2F2018%2F07%2F20%2FMVC-day0910%2F</url>
    <content type="text"><![CDATA[day9、10JavaBean是特殊的Java类，遵循特定的写法，特点如下： 必须有一个无参构造函数。 属性私有化。 私有属性可以通过public的getter、setter方法读写。 遵循命名规范。类名首字母大写，变量名、方法名首字母小写，多个单词组成，每个单词的首字母大写。 作用：JavaBean在J2EE开发中，通常用于封装数据，对于遵循以上写法的JavaBean组件，其它程序可以通过反射技术实例化JavaBean对象，并且通过反射那些遵守命名规范的方法，从而获知JavaBean的属性，进而调用其属性保存数据。————方立勋 属性修改器set前缀+属性名且第一个字母大写 属性访问器get方法 123456789101112131415161718192021public class Person &#123; private String name = "su"; // getClass() private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; jsp 中的 JavaBean 动作元素 jsp:useBean 查找或创建一个JavaBean组件。jsp:useBean标签用于在指定的域范围内查找指定名称的JavaBean对象，如果存在则直接返回该JavaBean对象的引用，如果不存在则实例化一个新的JavaBean对象并将它以指定的名称存储到指定的域范围中。 123&lt;jsp:useBean id="person" class="day09.Person" scope="page"&gt; &lt;/jsp:useBean&gt; &lt;%=person.getName()%&gt; id 属性用于指定JavaBean实例对象的引用名称和其存储在域范围中的名称。 class 属性用于指定JavaBean的完整类名（即必须带有包名）。 scope 属性用于指定JavaBean实例对象所存储的域范围，取值只能是page、request、session和application等四个值中的一个，其默认值是page。 scope=”session” //只在创建的时候执行 jsp:setProperty 设置组件属性。 12345678910111213141516&lt;jsp:useBean id="person" class="day09.Person" /&gt;&lt;jsp:setProperty name="person" property="name" value="xxx" /&gt; //setName&lt;%=person.getName()%&gt;&lt;%-- 用请求参数给bean赋值 --%&gt;&lt;jsp:setProperty name="person" property="name" param="name" /&gt;&lt;%=person.getName()%&gt;&lt;%=person.getAge()%&gt; //字符串转换成int&lt;jsp:setProperty name="person" property="birth" value="&lt;%=new Date()%&gt;"/&gt;&lt;%=person.getBirth()%&gt;&lt;%-- 用所有请求参数为bean赋值 --%&gt;&lt;jsp:setProperty name="person" property="*"/&gt;&lt;%=person.getName()%&gt;&lt;br/&gt;&lt;%=person.getAge()%&gt;&lt;br/&gt; http://localhost:8080/day09/2.jsp?name=123456789&amp;age=111 jsp:getProperty 获取组件属性。 1&lt;jsp:getProperty name="person" property="name"/&gt; 去Java代码 为空 -&gt; null -&gt; 判断返回值 -&gt; el表达式 Demo1 calcolator.jsp -&gt; myeclipsehttp://localhost:8080/day09/calcolator.jsp jsp开发模式 模式一：JSP+JavaBeans 简单 JSP页面独自响应请求并将处理结果返回客户。所有的数据通过bean来处理，JSP实现页面的表现。 模式二：JSP+JavaBeans+Servlet 复杂 Servlet处理用户请求，Servlet处理完后设置Bean的属性，JavaBean负责封装数据，JSP读取Bean的属性，然后输出显示。 JavaBean -&gt; Model 模型 Jsp -&gt; view 视图 servlet -&gt; Controller 控制器 用户通过浏览器访问jsp页面，在jsp上的所有操作都直接请求控制层 Servlet来完成。 web层servlet获取浏览器提交过来的参数传递到业务逻辑层中的Service中进行数据处理。 Service层将控制层传递过来的参数传递到Dao层(数据访问层)。 Dao层根据Service层的参数需求来访问数据库。 数据库根据Dao层的操作将数据集返回Dao层。 Dao层将获得的数据通过JavaBean对象进行封装，然后将封装好的数据返回给Service 层。 Service取出数据。 Service层将数据又封装到JavaBean返回给web层servlet。 web层servlet将得到的数据转发到对应的jsp页面给用户显示。 类 cn.itcast.domain // javabean cn.itcast.dao // dao接口 cn.itcast.dao.impl // dao实现 cn.itcast.service // service接口 cn.itcast.service.impl // Service实现 cn.itcast.web.ui // 页面 cn.itcast.utils // 工具类 cn.itcast.web.controller // LoginServlet 处理用户请求 junit.test // 测试类 web.listener web.Filer WEB-INF/jsp 存放jsp文件 阻止直接访问 便于维护 EL表达式 JSTL标签 ${…} -&gt; pageContext.findAttribute()找不到标识符返回空””,而不是null。 3.jsp + set city address 1234el表达式$(data)pageContext.findAttribute("data");//四个域查找顺序 page request session application 1234567891011121314151617&lt;% String datas = "asd"; request.setAttribute("dat", datas);%&gt;$&#123;dat&#125;&lt;%-- pageContext.findAttribute("data") page request session application --%&gt;&lt;% Person p = new Person(); p.setName("aaaa"); request.setAttribute("person", p);%&gt;$&#123;person.name&#125;&lt;%--pageContext.findAttribute("person") // page request session application--%&gt; JSTL标签 导包jstl.jar standerd.jar jsp页面中使用 &lt;% @ tablib url=”” prifix=”” %&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; uri 常用 &lt;c:foreach var=”” items=””&gt; &lt;c:if test=””&gt; 123456789101112131415161718192021222324252627&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;% List list = new ArrayList(); list.add(new Person("tt")); list.add(new Person("yy")); list.add(new Person("uu")); request.setAttribute("list", list); //放在req里%&gt;&lt;c:forEach items="$&#123;list&#125;" var="person"&gt; // EL里起别名 $&#123;person.name&#125; &lt;br /&gt; // ArrayList按顺序输出&lt;/c:forEach&gt;&lt;% Map map = new HashMap(); map.put("aa", new Person("aaaaa")); map.put("bb", new Person("bbbbb")); map.put("cc", new Person("ccccc")); map.put("dd", new Person("ddddd")); map.put("11", new Person("eeeee")); request.setAttribute("map", map);%&gt;&lt;c:forEach items="$&#123;map&#125;" var="entry"&gt; &lt;!-- map.entrySet() --&gt; $&#123;entry.key&#125;:$&#123;entry.value.name&#125; &lt;br /&gt; // 输出全部键值对&lt;/c:forEach&gt; 计算器 day9_user 搭建开发环境 导开发包dom4j开发包jstl开发包beanUtils开发包log4j开发包 创建组织程序的包 cn.itcast.domain // javabean 存放数据实体 cn.itcast.dao // dao接口 从实现中直接抽取出接口 cn.itcast.dao.impl // dao实现 cn.itcast.service // service接口 cn.itcast.service.impl // Service实现 处理servlet中实际的任务 cn.itcast.web.ui // 存放为用户提供用户界面servlet，此界面将调用相关的jsp页面进行跳转 cn.itcast.utils // 工具类 cn.itcast.web.controller // LoginServlet 处理 login.jsp 的数据 登录，注册，注销junit.test // 调试 WEB-INF/jsp // 保存所有jsp cn.itcast.exception // 异常处理包 cn.itcast.web.formbean // 返回表单数据封装包 在类目录下创建一个代表数据库的XML文件(users.xml) 开发实体 -&gt; domain User.java 开发dao(dao.impl) 开发utils 抽取接口UserDao.java(dao) XmlUtils.java (utils) 开发测试类:(junit.test) 开发service(对web层提供服务 -&gt; service.impl) 开发BusinessService 提取出接口（cn.itcast.service） 开发web层 开发注册 写一个RegisterUIServlet（cn.itcast.web.UI）为用户提供注册界面,它收到请求，跳到register.jsp(jsp) register.jsp register.jsp提交请求，交给RegisterServlet（cn.itcast.web.controller）处理 RegisterServlet 设计用于校验表单数据RegisterFormbean 写WebUtils工具类，封装请求数据到formbean中 如果校验失败跳回到register.jsp，并回显错误信息 如果校验通过，调用service向数据库中注册用户 开发登陆 LoginUIServlet（web.UI）收到请求，跳到login.jsp(jsp) login.jsp提交给LoginServlet（web.controller）处理登陆请求 注销。。。。。。。。。。 ||||||||||||测试的之后不应该查看src下面的users.xml，没有部署到服务器中，所有的java类放在classes目录中，改动之后的users.xml文件也会在此目录中。需要处理的异常，放在一个异常包中，创建时其继承的父类必须是java.lang.exception。 相对地址12&lt;form name="form1" method="post" action="$&#123;pageContext.request.contextPath&#125;/servlet/RegisterServlet"&gt;&lt;/form&gt; day9_user 注册实例 users.xml User.java dao.impl XmlUtils.java junit.test xml UserDao.java BusinessService BusinessServiceImpl UserExistException ServiceUtils junit.test 测试service index.jsp RegisterUIServlet register.jsp1. js RegisterServlet RegisterFormbean WebUtils LoginUIServlet login.jsp1. css LoginServlet LogoutServlet 开发service(对web层提供服务 -&gt; service.impl) 提取出接口（cn.itcast.service） 开发web层 开发注册 写一个RegisterUIServlet（cn.itcast.web.UI）为用户提供注册界面,它收到请求，跳到register.jsp(jsp) register.jsp register.jsp提交请求，交给RegisterServlet（cn.itcast.web.controller）处理 RegisterServlet 设计用于校验表单数据RegisterFormbean 写WebUtils工具类，封装请求数据到formbean中 如果校验失败跳回到register.jsp，并回显错误信息 如果校验通过，调用service向数据库中注册用户 开发登陆 LoginUIServlet（web.UI）收到请求，跳到login.jsp(jsp) login.jsp提交给LoginServlet（web.controller）处理登陆请求 注销。。。。。。。。。。 day_gwcar 购物车]]></content>
      <tags>
        <tag>Javaweb</tag>
        <tag>Mvc</tag>
        <tag>Day0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2018%2F07%2F20%2Fmysql%2F</url>
    <content type="text"><![CDATA[MySQL常见数据库1. MySQL 开源 2. SQL Server 微软 3. Oracle 甲骨文 Java 4. DB2 IBM 关系型数据库 命令行 链接MySQL数据库 1mysql -u 用户名 -p 密码 -- mysql -u root -p 123456 默认端口：3306 12SQL注释 --这是一个注释 1mysql&gt; \s --查看当前信息 操作数据库12345CREATE DATABASE [if not exists] db_name[][][]character set charset_name -- 编码方式 utf8collate collation_name -- 排序方式 12-- 库的创建细节SHOW cerate DATABASE mysql3; 12-- 删除库DROP DATABASE [IF EXISTS] db_name; 1234567-- 修改数据库-- 不能修改库的名称ALTER DATABASE [IF NOT EXISTS] db_name[alter_specification [, alter_specification] ...]ALTER DATABASE MySQL3 character set gb2312;show CREATE DATABASE MySQL3; 123456789101112131415161718-- 备份数据库mysqldump -u 用户名 -p 数据库名 &gt; 文件名.sql -- (window命令)mysqldump -u root -p mysql3&gt;c:\mysql3.sqlroot-- 恢复数据库 1-- 只能恢复数据，不能恢复库Source 文件名.sql -- (sql语句) 可以执行sql脚本-- 先创建库，再恢复CREATE DATABASE mysql3;use mysql3;mysql&gt;source c:\mysql3.sql-- 恢复数据库 2-- 先创建库，再恢复CREATE DATABASE mysql3;mysql -u root -p root mysql3&lt;c:\mysql3.sql; -- (window命令) MySQL常用数据类型 分类 数据类型 说明 数值类型 BIT(M) 位类型。M指定位数，默认值1，范围1-64 TINYINT [UNSIGNED] [ZEROFILL] 带符号的范围是-128到127。无符号0到255。 BOOL，BOOLEAN 使用0或1表示真或假 SMALLINT [UNSIGNED] [ZEROFILL] 2的16次方 INT [UNSIGNED] [ZEROFILL] 2的32次方 BIGINT [UNSIGNED] [ZEROFILL] 2的64次方 FLOAT[(M,D)] [UNSIGNED] [ZEROFILL] M指定显示长度，d指定小数位数 DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL] 表示比float精度更大的小数 Decimal(M,D) 定点数，存储货币等精度要求高的数据 文本、二进制类型 CHAR(size) char(20) 固定长度字符串,最大255 VARCHAR(size) varchar(20) 可变长度字符串，最大65000 BLOB LONGBLOB 二进制数据 TEXT(clob) LONGTEXT(longclob) 大文本 时间日期 DATE/DATETIME/TimeStamp 日期类型(YYYY-MM-DD) (YYYY-MM-DD HH:MM:SS)，TimeStamp表示时间戳，它可用于自动记录insert、update操作的时间]]></content>
      <tags>
        <tag>Javaweb</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包管理]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[auto-apt 、checkinstall安装auto-apt和check1installapt install auto-apt checkinstall 在源码目录中123auto-apt run ./configuremakecheckinstall 这样会生成一个deb包，卸载和重新安装就非常方便了 完全卸载 (packagename具体的名字在checkintall完成之后会有提示1dpkg -r packagename 用生成的deb包重新安装1dpkg -i ****.deb 更多命令列出包中安装的文件位置1dpkg -L packagename 检查是否安装成功1dpkg -l | grep packagename 同上1apt list --installed | grep packagename 引自知乎：Kevin Li]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决github网页排版乱码问题]]></title>
    <url>%2F2018%2F07%2F20%2F%E8%A7%A3%E5%86%B3github%E7%BD%91%E9%A1%B5%E6%8E%92%E7%89%88%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解决github网页排版乱码问题。######[2018.06.05] 复制 assets-cdn.github.com 到 https://www.ipaddress.com/或直接访问 :http://assets-cdn.github.com.ipaddress.com/ 把查到的最优地址加入到本地Hosts里。Hosts路径：1C:\Windows\System32\drivers\etc 12151.101.184.133 assets-cdn.github.com151.101.12.133 assets-cdn.github.com]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建博客]]></title>
    <url>%2F2018%2F07%2F19%2FHexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[配置本地1. 安装 Node.js 1sudo apt install nodejs 2. 安装Hexo 12npm install hexo-cli -gnpm install hexo --save 3. 查看版本 123nodejs -vnpm -vgit --version 4. 配置hexo1. 初始化Hexo本地新建blog文件夹必须为空 12cd bloghexo init 2. install 1npm install 3. 发布 1hexo g 4. 本地预览 1hexo server 5. 配置Git 12git config --global user.name &quot;zhichengroup&quot;git config --global user.email &quot;zhichengroup@email.com&quot; 6. 生成密钥 123cd ~/.ssh //检查ssh key是否存在ls -&gt; id_isa id_isa.pubssh-keygen -t rsa -C &quot;zhichengroup@email.com&quot; //生成 7. 添加密钥到ssh-agentstart the ssh-agent in the background 12eval &quot;$(ssh-agent -s)&quot;ssh-add ~/.ssh/id_rsa 8. 配置Deployment 在 ~blog / _config.yml文件中 12345Deploymentdeploy:type: gitrepo: git@github.com:zhichengroup/zhichengroup.github.io.gitbranch: master 9. 安装扩展 12npm install hexo-deployer-git --save不然会提示`deloyer not found:git` 10. 在Github中 创建仓库 -&gt; settings -&gt; Theme Chooser -&gt; Theme Choose a theme11. 在Github中添加 ssh id_rsa.pub 1ssh -T git@github.com // 检查 12. 安装search pwa 1234npm install hexo-generator-json-content@2.2.0 --savenpm install --save hexo-generator-searchnpm install --save hexo-generator-searchdbnpm install --save hexo-offline 发布文章1. 新建博文 1hexo new post &quot;test1&quot; 会在 ~/blog/source/_posts目录下生成md文件。 2. 预览 1hexo server 3. 发布 12hexo g // 生成hexo d // 部署 或 hexo d -g Hexo doc theme参考链接 参考链接 参考链接]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test1]]></title>
    <url>%2F2018%2F07%2F19%2Ftest1%2F</url>
    <content type="text"><![CDATA[[toc] h1 111 222 333h2h3h4h5h6]]></content>
  </entry>
</search>
